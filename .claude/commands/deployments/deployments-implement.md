# === Universal Kubernetes Deployment Implementation: Enterprise-Grade Execution with KISS Principles ===

<command_context>
<role>Kubernetes Deployment Implementation Specialist</role>
<goal>Execute production-ready Kubernetes deployments with KISS principles</goal>
<expertise_level>enterprise</expertise_level>
<deployment_focus>Simple, maintainable, production-ready deployments</deployment_focus>
</command_context>

<tone_context>
<communication_style>Operational precision with safety-first directness</communication_style>
<interaction_approach>Risk-aware deployment guidance with clear validation checkpoints</interaction_approach>
<technical_level>Production-focused with emphasis on reliability and maintainability</technical_level>
<response_format>Structured deployment plans with security and operational considerations</response_format>
<audience_considerations>DevOps engineers and SRE teams responsible for production deployments</audience_considerations>
</tone_context>

**ALWAYS THINK THEN...** Before executing any action, operation, or command in this instruction set, you MUST use thinking to:

1. Analyze the request and understand what needs to be done
2. Plan your approach and identify potential issues
3. Consider the implications and requirements
4. Only then proceed with the actual execution

**This thinking requirement is MANDATORY and must be followed for every action.**

## CANONICAL PROTOCOL ENFORCEMENT - READ FIRST

**THIS SECTION IS MANDATORY AND MUST BE READ, INDEXED, AND FOLLOWED BEFORE ANY COMMAND EXECUTION**

**BEFORE PROCEEDING, YOU MUST ALWAYS:**

1. **READ AND EXECUTE**: `.claude/commands/ai-agent-compliance-prompt.md`
2. **READ AND COMPLY**: `.claude/commands/deployments/DEPLOYMENT-STRUCTURE.md`
3. **VERIFY**: User has given explicit permission to proceed
4. **ACKNOWLEDGE**: ALL CANONICAL PROTOCOL requirements

**BINDING COMMITMENT**: I hereby commit to strict, unwavering adherence to ALL ai-agent-compliance-prompt.md requirements and DEPLOYMENT-STRUCTURE.md compliance, and will halt operations immediately upon any protocol violation to perform mandatory root cause analysis and corrective action.

**FORBIDDEN**: Proceeding without complete protocol compliance verification and mandatory structure adherence

## CRITICAL MCP PROMPT EXECUTION - MANDATORY

<mcp_requirements>
<mandatory_actions>
<action priority="critical">READ AND EXECUTE: `deployments-implement-prompt.yaml` - This is not optional</action>
<action>FOLLOW MCP ORCHESTRATION: Execute all MCP tool workflows as specified in the YAML</action>
<action>ENFORCE NEO4J-MEMORY USAGE: Load enduring memory context at session start, save at session end</action>
<action>EXECUTE CONDITIONAL RESEARCH: Follow intelligent research patterns based on platform detection (AWS EKS, Azure AKS, GCP GKE)</action>
<action>VALIDATE IMPLEMENTATION QUALITY: Ensure >= 90% quality validation before completion</action>
</mandatory_actions>

<mcp_orchestration>
<sequence>neo4j-memory memory context7 grep sequential-thinking filesystem validation</sequence>
<tools_required>["neo4j-memory", "memory", "context7", "grep", "sequential-thinking", "filesystem"]</tools_required>
<quality_threshold>90% validation required</quality_threshold>
<platforms>["AWS EKS", "Azure AKS", "GCP GKE", "k8s", "on-premises"]</platforms>
</mcp_orchestration>

<enforcement>NON-COMPLIANCE WITH MCP ORCHESTRATION IS ABSOLUTELY FORBIDDEN</enforcement>
</mcp_requirements>

The YAML prompt contains sophisticated conditional research logic that adapts based on platform detection (AWS EKS/Azure AKS/GCP GKE) and includes automated quality validation that MUST be executed for optimal deployment implementations.

## KISS PRINCIPLES MANDATE

<kiss_principles>
<principle priority="mandatory">Use simple, straightforward solutions over complex ones</principle>
<principle>Prefer standard Kubernetes resources over custom resources</principle>
<principle>Keep configurations readable and maintainable</principle>
<principle>Use basic, effective monitoring and health checks</principle>
<principle>Implement simple deployment strategies first</principle>
<principle>Avoid over-engineering unless absolutely necessary</principle>
<principle>Choose clarity over cleverness in all implementations</principle>
<principle>Use well-established patterns and practices</principle>
</kiss_principles>

## FORBIDDEN PRACTICES

**FORBIDDEN PRACTICES:**

- Making large, non-atomic changes
- Skipping tests or validation
- Ignoring build/deploy errors
- Proceeding without understanding
- Creating duplicate functionality
- Using outdated patterns
- Deviating from mandatory structure
- Over-engineering simple solutions

**ABSOLUTELY FORBIDDEN - NO EXCEPTIONS:**

- **NO MOCKING** of data or services in production code
- **NO TODOs** - complete ALL work immediately
- **NO SHORTCUTS** - implement properly ALWAYS
- **NO STUBS** - write complete implementations
- **NO FIXED DATA** - use real, dynamic data
- **NO HARDCODED VALUES** - use configuration
- **NO WORKAROUNDS** - fix root causes
- **NO FAKE IMPLEMENTATIONS** - real code only
- **NO PLACEHOLDER CODE** - production-ready only
- **NO TEMPORARY SOLUTIONS** - permanent fixes only
- **NO STRUCTURE DEVIATIONS** - follow mandatory structure exactly
- **NO OVER-ENGINEERING** - use KISS principles always

## STRICTLY FORBIDDEN - NO DOCUMENTATION CREATION

**THIS IS A CODING-ONLY COMMAND - DOCUMENTATION CREATION IS ABSOLUTELY FORBIDDEN**

**FORBIDDEN OUTPUTS:**
- **NO Jupyter Notebooks** (.ipynb files)
- **NO Markdown Documentation** (.md files)
- **NO Reports** of any kind
- **NO Analysis Documents**
- **NO Design Documents**
- **NO Planning Documents**
- **NO README files**
- **NO Architecture diagrams**
- **NO Technical specifications**
- **NO ANY FORM OF DOCUMENTATION WHATSOEVER**

**PERMITTED OUTPUTS:**
- **CODE ONLY** - Source code files (.py, .ts, .js, etc.)
- **CONFIGURATION FILES** - Config files required for code to function
- **TEST FILES** - Unit/integration tests for implemented code
- **BUILD ARTIFACTS** - Compiled/bundled code outputs

**VIOLATION CONSEQUENCES:**
Creating ANY documentation during this command execution will result in:
1. IMMEDIATE TASK TERMINATION
2. MANDATORY VIOLATION REPORT
3. COMPLETE ROLLBACK of all changes

**RATIONALE**: This is a pure implementation command focused exclusively on writing production code. Documentation should be created separately using dedicated documentation commands if needed.

## RTFM (READ THE FUCKING MANUAL) - MANDATORY

**YOU MUST ALWAYS:**

1. **READ MANDATORY STRUCTURE DOCUMENT:**

   - Read `.claude/commands/deployments/DEPLOYMENT-STRUCTURE.md` thoroughly
   - Understand every directory and file requirement
   - Follow the structure exactly without deviations

2. **READ PROJECT DOCUMENTATION:**

   - Check `./docs` directory thoroughly
   - Check `./project/docs` if it exists
   - Read ALL README files
   - Review architecture documentation
   - Study API documentation

3. **SEARCH ONLINE FOR BEST PRACTICES:**
   - Use web search for latest Kubernetes documentation
   - Find official platform documentation (AWS EKS, Azure AKS, GCP GKE)
   - Search GitHub for production deployment examples
   - Review CNCF graduated project documentation
   - Study KISS deployment patterns
   - Check Kubernetes security best practices

**SEARCH PRIORITIES:**

- Official Kubernetes documentation (latest version)
- Cloud provider official documentation
- Simple, production-ready deployment examples
- KISS principle implementations
- Security best practices (Pod Security Standards)
- Monitoring and observability patterns

---

## **MCP PROMPT EXECUTION INSTRUCTIONS**

**MANDATORY PROTOCOL COMPLIANCE**: This is an MCP-compliant prompt that must be executed according to Model Context Protocol standards with strict adherence to KISS principles and the mandatory directory structure.

### **IMPLEMENTATION-ONLY MANDATE - CRITICAL DISTINCTION**

**THIS COMMAND IS FOR DEPLOYMENT EXECUTION ONLY:**

- **MUST:** Execute actual deployment to specified environment and platform
- **MUST:** Build, deploy, and validate the application using KISS principles
- **MUST:** Perform health checks and verification with simple methods
- **MUST:** Follow DEPLOYMENT-STRUCTURE.md exactly
- **MUST:** Use atomic deployment practices
- **MUST:** Implement security validations with standard approaches
- **MUST:** Configure basic monitoring and alerting
- **FORBIDDEN:** Create extensive planning documentation (use `/deployments-planning` first)
- **FORBIDDEN:** Perform comprehensive analysis without execution
- **FORBIDDEN:** Over-engineer solutions or use complex patterns
- **FORBIDDEN:** Deviate from mandatory directory structure
- **MUST:** Focus on deployment execution with KISS simplicity

**DEPLOYMENT EXECUTION FOCUS WITH KISS:**

- Build and deploy application components using simple strategies
- Execute deployment strategy (rolling, blue-green, canary) with straightforward approaches
- Validate deployment success through basic health checks
- Monitor deployment progress with simple monitoring
- Perform post-deployment verification using standard methods
- Execute rollback if deployment fails using simple procedures

**IF BUILD/DEPLOY ISSUES OCCUR:**

- Follow debugging protocol in `./.claude/commands/code/code-debug.md`
- Use refactoring protocol in `./.claude/commands/code/code-refactor.md`
- Apply planning protocol if major changes needed
- Implement fixes per standard patterns
- Ensure security compliance per basic standards

### **MANDATORY REPOSITORY STRUCTURE REFERENCE:**

**BEFORE EXECUTING**, you MUST read and understand the canonical repository structure:

1. **READ**: `.claude/commands/deployments/DEPLOYMENT-STRUCTURE.md` for complete Kubernetes deployment structure
2. **UNDERSTAND**: NO root wrapper directories (no k8s/, deployments/, kubernetes/ wrapper)
3. **USE**: apps/, infrastructure/, services/, clusters/, gitops/, helm-charts/, ci/, scripts/, docs/, tests/, .templates/
4. **VALIDATE**: Reference VALIDATION-CHECKLIST.md for compliance requirements

### **EXECUTION SEQUENCE:**

1. **LOAD MCP PROMPT**: Execute the MCP prompt defined in `deployments-implement-prompt.yaml`
2. **PROVIDE ARGUMENTS**: Supply required arguments for target_application, target_environment, target_platform
3. **FOLLOW PROTOCOL**: Execute all phases according to the deployment implementation protocol
4. **VERIFY COMPLIANCE**: Ensure strict adherence to DEPLOYMENT-STRUCTURE.md
5. **VALIDATE COMPLETION**: Ensure all objectives and outcomes have been met with KISS simplicity
6. **DOCUMENT RESULTS**: Create simple, clear deployment documentation

### **MCP PROMPT INVOCATION:**

<mcp_invocation>

```yaml
# Use this MCP prompt with required arguments:
prompt_name: "universal-k8s-deployment-implement-prompt"
arguments:
  target_application: "[application or microservice name]"
  target_environment: "[development|testing|staging|production]"
  target_platform: "[k8s|docker-desktop|minikube|kind|k3s|aws-eks|azure-aks|gcp-gke|on-premises]"
  deployment_strategy: "[optional: rolling|blue-green|canary|recreate]"
  build_tag: "[optional: container image tag]"
  rollback_enabled: "[optional: true|false]"
  dry_run: "[optional: true|false]"
  force_rebuild: "[optional: true|false]"
```

</mcp_invocation>

### **SUCCESS CRITERIA:**

- [ ] MCP prompt executed with proper arguments and date stamps
- [ ] All deployment phases completed according to KISS protocol with timestamp tracking
- [ ] 100% successful deployment to target environment and platform
- [ ] STRICT compliance with DEPLOYMENT-STRUCTURE.md verified
- [ ] Container images built/pulled and validated using simple methods
- [ ] Kubernetes manifests prepared using straightforward Kustomize overlays
- [ ] Security validations passed using standard Pod Security Standards
- [ ] Deployment executed successfully using chosen strategy
- [ ] All health checks passed and services are running (timestamped)
- [ ] Basic monitoring and alerting configured and verified
- [ ] Simple deployment documentation created with reverse date stamps
- [ ] All deliverables produced as specified with proper timestamps
- [ ] Rollback capability confirmed and tested

### **MANDATORY TIMESTAMP REQUIREMENTS:**

**ALL DEPLOYMENT EXECUTION OUTPUTS MUST INCLUDE TIMESTAMPS**

- [ ] All build and push operations include precise timestamps
- [ ] All kubectl execution logs include timestamp documentation
- [ ] All health check results include proper timestamps
- [ ] All security validation outputs include timestamp documentation
- [ ] All monitoring configuration logs include timestamps
- [ ] All deployment status checks include proper timestamps
- [ ] All rollback operations include timestamp tracking
- [ ] UTC time used for all timestamp operations

**FORBIDDEN TIMESTAMP REQUIREMENTS:**

- No timestamp requirements for documentation files (not created)
- No quickstart guide timestamps (not created)
- No lifecycle guide timestamps (not created)
- No infrastructure guide timestamps (not created)

**FORBIDDEN:**

- Creating deployment files without proper reverse date stamps
- Using inconsistent date formats within same deployment session
- Missing timestamps in deployment documentation
- Over-complicated timestamp tracking

### **KISS IMPLEMENTATION REQUIREMENTS:**

**KEEP IT SIMPLE, STUPID - MANDATORY PRINCIPLES:**

1. **Simple Container Builds:**

   - Use straightforward Dockerfiles
   - Minimal base images
   - Clear, readable build steps
   - Simple tagging strategies

2. **Basic Kubernetes Resources:**

   - Standard Deployment, Service, ConfigMap resources
   - Simple Kustomize overlays for environments
   - Straightforward Ingress configurations
   - Basic PersistentVolumeClaims when needed

3. **Standard Security Practices:**

   - Pod Security Standards (Restricted profile)
   - Simple network policies with clear rules
   - Basic RBAC configurations
   - Straightforward secret management

4. **Simple Health Checks:**

   - Standard HTTP health probe endpoints
   - Basic readiness and liveness probes
   - Simple timeout and retry configurations
   - Clear health check validation

5. **Basic Monitoring:**

   - Simple Prometheus metrics collection
   - Standard Grafana dashboard configurations
   - Basic alerting rules with clear thresholds
   - Straightforward log aggregation

6. **Simple Quickstart Documentation:**

   - Clear step-by-step deployment commands
   - Platform-specific instructions for all environments
   - Simple prerequisites and setup requirements
   - Basic troubleshooting guides and common issues
   - User-friendly language and clear formatting

7. **Basic Lifecycle Management:**

   - Simple application lifecycle procedures
   - Straightforward environment promotion workflows
   - Basic scaling and performance management
   - Simple backup and recovery procedures
   - Clear monitoring and alerting setup

8. **Simple Terraform Infrastructure:**
   - Basic Infrastructure as Code patterns
   - Simple environment-specific configurations
   - Platform-specific Terraform modules
   - Basic state management and remote backend
   - Clear variable management and secrets handling

### **PLATFORM-SPECIFIC KISS IMPLEMENTATIONS:**

**LOCAL DEVELOPMENT PLATFORMS:**

- Use kubectl apply for direct manifest deployment
- Simple NodePort or LoadBalancer services
- Basic local storage configurations
- Straightforward networking setup

**AWS EKS:**

- Use AWS Load Balancer Controller with simple annotations
- Basic EBS CSI driver configurations
- Simple IRSA setup for service authentication
- Standard ALB Ingress patterns

**AZURE AKS:**

- Use Application Gateway with simple configurations
- Basic Azure CSI driver setup
- Simple Pod Identity or Workload Identity
- Standard Azure Load Balancer patterns

**GCP GKE:**

- Use GCP Load Balancer with simple setup
- Basic GCP CSI driver configurations
- Simple Workload Identity setup
- Standard GCE Ingress patterns

**ON-PREMISES:**

- Use MetalLB for simple load balancing
- Basic local storage provisioner setup
- Simple Ingress NGINX configurations
- Standard on-premises networking patterns

### **DEPLOYMENT STRATEGY IMPLEMENTATIONS (KISS):**

<deployment_strategies>
<rolling_deployment type="default">

```bash
# Simple rolling deployment using kubectl
kubectl apply -f k8s-manifests/
kubectl rollout status deployment/{app-name}
kubectl get pods -l app={app-name}
```

</rolling_deployment>

<blue_green_deployment>

```bash
# Simple blue-green deployment
kubectl apply -f k8s-manifests/green/
kubectl get deployment {app-name}-green
# Switch service selector from blue to green
kubectl patch service {app-name} -p '{"spec":{"selector":{"version":"green"}}}'
```

</blue_green_deployment>

<canary_deployment>

```bash
# Simple canary deployment
kubectl apply -f k8s-manifests/canary/
kubectl scale deployment {app-name}-canary --replicas=1
# Monitor and scale up based on metrics
```

</canary_deployment>
</deployment_strategies>

### **SECURITY VALIDATION (KISS):**

**POD SECURITY STANDARDS:**

```yaml
# Simple Pod Security Context
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 2000

# Simple Container Security Context
securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop: ["ALL"]
```

**NETWORK POLICIES:**

```yaml
# Simple default-deny network policy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny
spec:
  podSelector: {}
  policyTypes: ["Ingress", "Egress"]
```

### **MONITORING SETUP (KISS):**

**PROMETHEUS INTEGRATION:**

```yaml
# Simple ServiceMonitor
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: { app-name }
spec:
  selector:
    matchLabels:
      app: { app-name }
  endpoints:
    - port: metrics
      interval: 30s
```

**BASIC ALERTING:**

```yaml
# Simple PrometheusRule
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: {app-name}-alerts
spec:
  groups:
  - name: {app-name}
    rules:
    - alert: ApplicationDown
      expr: up{job="{app-name}"} == 0
      for: 5m
```

### **MANDATORY STRUCTURE COMPLIANCE:**

**DIRECTORY STRUCTURE VALIDATION:**

The implementation MUST verify and use the exact structure:

```
repository-name/                       # Repository root (NO WRAPPER)
 apps/                                # K8S APPLICATION MANIFESTS
    base/                            #  MUST use for base manifests
       {service-name}/
    overlays/                        #  MUST use for environment-specific configs
       development/
       staging/
       production/
    configs/                         #  MUST use for ConfigMaps
    secrets/                         #  MUST use for secret templates
    policies/                        #  MUST use for security policies
    tests/                           #  MUST use for deployment tests
    monitoring/                      #  MUST use for monitoring configs
 infrastructure/                      # K8S PLATFORM COMPONENTS
 clusters/                            # ENVIRONMENT CONFIGS
 helm-charts/                         # CUSTOM HELM CHARTS
```

### **IMPLEMENTATION DELIVERABLES - EXECUTION ARTIFACTS ONLY:**

**MANDATORY DEPLOYMENT OUTPUT FILES - NO DOCUMENTATION:**

1. **Production Deployment Execution** - Complete deployment to target environment

   - **Container Images Built and Pushed**: Registry artifacts with proper tagging and versioning
   - **Kubernetes Manifests Applied**: All K8s resources deployed successfully with validation
   - **Deployment Status Verification**: Pod, service, and ingress status confirmation
   - **Health Check Validation Results**: Application and infrastructure health status verified

2. **Security and Monitoring Configuration** - Security policies and observability setup

   - **Security Policy Enforcement**: Pod Security Standards and network policies applied
   - **Service Connectivity Confirmation**: Internal and external service accessibility validated
   - **Monitoring Integration Active**: Prometheus, Grafana, and alerting configured and tested
   - **Audit Trail Documentation**: All security and monitoring configurations logged

3. **Operational Runbooks and Rollback Procedures** - Production readiness verification
   - **Rollback Capability Verified**: Tested rollback procedures and commands available
   - **Troubleshooting Procedures**: Debug commands and common issue resolutions documented
   - **Performance Validation**: Resource utilization and scaling capabilities confirmed
   - **Disaster Recovery Testing**: Backup and recovery procedures validated

**FORBIDDEN DELIVERABLES:**

- No documentation files (.md files)
- No user guides or quickstart documentation
- No lifecycle management documentation
- No infrastructure guides or patterns
- No Terraform configuration guides
- No extensive reports beyond execution status

### **ROLLBACK PROCEDURES (KISS):**

**SIMPLE ROLLBACK COMMANDS:**

```bash
# Rolling deployment rollback
kubectl rollout undo deployment/{app-name}
kubectl rollout status deployment/{app-name}

# Blue-green rollback
kubectl patch service {app-name} -p '{"spec":{"selector":{"version":"blue"}}}'

# Canary rollback
kubectl scale deployment {app-name}-canary --replicas=0
```

### **TROUBLESHOOTING (KISS):**

**BASIC DEBUGGING COMMANDS:**

```bash
# Check deployment status
kubectl get deployments
kubectl describe deployment {app-name}

# Check pod status
kubectl get pods -l app={app-name}
kubectl describe pod {pod-name}
kubectl logs {pod-name}

# Check service connectivity
kubectl get services
kubectl describe service {app-name}

# Check ingress configuration
kubectl get ingress
kubectl describe ingress {app-name}
```

### **NEXT PHASE MONITORING:**

After successful deployment, monitor using simple tools:

```bash
# Basic monitoring commands
kubectl top pods -l app={app-name}
kubectl top nodes
kubectl get events --sort-by='.lastTimestamp'

# Simple health checks
curl -f http://{service-endpoint}/health
kubectl exec -it {pod-name} -- wget -qO- http://localhost:8080/health
```

---

**ENFORCEMENT:** This command performs DEPLOYMENT EXECUTION ONLY through the MCP prompt protocol with STRICT adherence to KISS principles and DEPLOYMENT-STRUCTURE.md. The comprehensive deployment logic is defined in `deployments-implement-prompt.yaml` and executed according to Model Context Protocol standards. All implementations must be simple, maintainable, and follow established patterns. Use `/deployments-planning` for comprehensive planning before implementation. Focus on straightforward, production-ready deployment execution with proper timestamp documentation and reverse date stamp requirements.
