# === Python Code Implementation: AI-Driven Production-Ready Python Code Implementation Protocol ===

**ALWAYS THINK THEN...** Before executing any action, operation, or command in this instruction set, you MUST use thinking to:

1. Analyze the request and understand what needs to be done
2. Plan your approach and identify potential issues
3. Consider the implications and requirements
4. Only then proceed with the actual execution

**This thinking requirement is MANDATORY and must be followed for every action.**

## CANONICAL PROTOCOL ENFORCEMENT - READ FIRST

**THIS SECTION IS MANDATORY AND MUST BE READ, INDEXED, AND FOLLOWED BEFORE ANY COMMAND EXECUTION**

**BEFORE PROCEEDING, YOU MUST ALWAYS:**

1. **READ AND EXECUTE**: `.claude/commands/ai-agent-compliance-prompt.md`
2. **VERIFY**: User has given explicit permission to proceed
3. **ACKNOWLEDGE**: ALL CANONICAL PROTOCOL requirements

**BINDING COMMITMENT**: I hereby commit to strict, unwavering adherence to ALL ai-agent-compliance-prompt.md requirements and will halt operations immediately upon any protocol violation to perform mandatory root cause analysis and corrective action.

**FORBIDDEN**: Proceeding without complete protocol compliance verification

## CRITICAL MCP PROMPT EXECUTION - MANDATORY

**THIS SECTION IS ABSOLUTELY MANDATORY - NON-COMPLIANCE FORBIDDEN**

**BEFORE ANY PYTHON IMPLEMENTATION, YOU MUST:**

1. **READ AND EXECUTE**: `python-code-framework-implement-prompt.yaml` - This is not optional
2. **FOLLOW MCP ORCHESTRATION**: Execute all MCP tool workflows as specified in the YAML
3. **ENFORCE NEO4J-MEMORY USAGE**: Load enduring memory context at session start, save at session end
4. **EXECUTE CONDITIONAL RESEARCH**: Follow intelligent research patterns based on project type detection (FastAPI, Django, Data Science)
5. **VALIDATE IMPLEMENTATION QUALITY**: Ensure >= 90% quality validation before completion

**MCP ORCHESTRATION REQUIREMENTS:**
-  Neo4j-memory (enduring memory) for Python pattern persistence across projects
-  Memory (temporal memory) for session implementation progress tracking
-  Context7 for Python 3.11+, FastAPI, Django, and framework-specific documentation
-  Grep for intelligent GitHub pattern research based on detected project type
-  Sequential-thinking for adaptive SOLID principles planning and quality validation
-  Filesystem for code analysis and production-ready implementation
-  Automated quality validation with conditional re-validation workflows

**NON-COMPLIANCE WITH MCP ORCHESTRATION IS ABSOLUTELY FORBIDDEN**

The YAML prompt contains sophisticated conditional research logic that adapts based on project type detection (FastAPI/Django/Data Science) and includes automated quality validation that MUST be executed for optimal Python implementations.

## FORBIDDEN PRACTICES

**FORBIDDEN PRACTICES:**

- Making large, non-atomic changes
- Skipping tests or validation
- Ignoring build/deploy errors
- Proceeding without understanding
- Creating duplicate functionality
- Using outdated patterns

**ABSOLUTELY FORBIDDEN - NO EXCEPTIONS:**

- **NO MOCKING** of data or services in production code
- **NO TODOs** - complete ALL work immediately
- **NO SHORTCUTS** - implement properly ALWAYS
- **NO STUBS** - write complete implementations
- **NO FIXED DATA** - use real, dynamic data
- **NO HARDCODED VALUES** - use configuration
- **NO WORKAROUNDS** - fix root causes
- **NO FAKE IMPLEMENTATIONS** - real code only
- **NO PLACEHOLDER CODE** - production-ready only
- **NO TEMPORARY SOLUTIONS** - permanent fixes only

## STRICTLY FORBIDDEN - NO DOCUMENTATION CREATION

**THIS IS A CODING-ONLY COMMAND - DOCUMENTATION CREATION IS ABSOLUTELY FORBIDDEN**

**FORBIDDEN OUTPUTS:**
- **NO Jupyter Notebooks** (.ipynb files)
- **NO Markdown Documentation** (.md files)
- **NO Reports** of any kind
- **NO Analysis Documents**
- **NO Design Documents**
- **NO Planning Documents**
- **NO README files**
- **NO Architecture diagrams**
- **NO Technical specifications**
- **NO ANY FORM OF DOCUMENTATION WHATSOEVER**

**PERMITTED OUTPUTS:**
- **CODE ONLY** - Source code files (.py, .ts, .js, etc.)
- **CONFIGURATION FILES** - Config files required for code to function
- **TEST FILES** - Unit/integration tests for implemented code
- **BUILD ARTIFACTS** - Compiled/bundled code outputs

**VIOLATION CONSEQUENCES:**
Creating ANY documentation during this command execution will result in:
1. IMMEDIATE TASK TERMINATION
2. MANDATORY VIOLATION REPORT
3. COMPLETE ROLLBACK of all changes

**RATIONALE**: This is a pure implementation command focused exclusively on writing production code. Documentation should be created separately using dedicated documentation commands if needed.

## RTFM (READ THE FUCKING MANUAL) - MANDATORY

**YOU MUST ALWAYS:**

1. **READ JUPYTER NOTEBOOKS:**

   - Search for .ipynb files in the repository
   - Read implementation notebooks for context
   - Review analysis notebooks for insights
   - Study documentation notebooks for patterns

2. **READ PROJECT DOCUMENTATION:**

   - Check `./docs` directory thoroughly
   - Check `./project/docs` if it exists
   - Read ALL README files
   - Review architecture documentation
   - Study API documentation

3. **SEARCH ONLINE FOR BEST PRACTICES:**
   - Use web search for latest documentation
   - Find official framework/library docs
   - Search GitHub for example implementations
   - Review industry best practices
   - Study similar successful projects
   - Check Stack Overflow for common patterns

**SEARCH PRIORITIES:**

- Official documentation (latest version)
- GitHub repositories with high stars
- Industry standard implementations
- Recent blog posts/tutorials (< 1 year old)
- Community best practices

---

## **MCP PROMPT EXECUTION INSTRUCTIONS**

**MANDATORY PROTOCOL COMPLIANCE**: This is an MCP-compliant prompt that must be executed according to Model Context Protocol standards.

### **PYTHON CODE IMPLEMENTATION-ONLY MANDATE - CRITICAL DISTINCTION**

**THIS COMMAND IS FOR PYTHON CODE IMPLEMENTATION ONLY:**

- **MUST:** Implement complete production-ready Python code from designs
- **MUST:** Implement all classes, interfaces, and architectural patterns
- **MUST:** Apply SOLID, DRY, KISS principles to all implementations
- **MUST:** Implement complete Python best practices and modern features
- **FORBIDDEN:** Creating test code or test scripts
- **FORBIDDEN:** Writing external documentation
- **FORBIDDEN:** Creating duplicate or backup files
- **MUST:** Document with docstrings and comments only

**PYTHON CODE IMPLEMENTATION FOCUS AREAS:**

- Core class hierarchies and abstract base class implementation
- SOLID principles implementation in Python code
- Design patterns implementation (Factory, Strategy, Observer, etc.)
- Modern Python features implementation (dataclasses, typing, async)
- Error handling and exception architecture implementation
- Type system and static analysis implementation
- Performance optimization and scalability implementation

### **EXECUTION SEQUENCE:**

1. **LOAD MCP PROMPT**: Execute the MCP prompt defined in `python-code-framework-implement-prompt.yaml`
2. **PROVIDE ARGUMENTS**: Supply required arguments for implementation_target and design_source
3. **FOLLOW PROTOCOL**: Execute all phases according to the implementation protocol specifications
4. **VERIFY COMPLETION**: Ensure all objectives and outcomes have been met
5. **DOCUMENT RESULTS**: Create comprehensive implementation documentation
6. **VALIDATE COMPLIANCE**: Confirm 100% implementation success achieved

### **MCP PROMPT INVOCATION:**

```yaml
# Use this MCP prompt with required arguments:
prompt_name: "python-code-framework-implement-prompt"
arguments:
  implementation_target: "[complete-architecture|core-classes|design-patterns|modern-features]"
  design_source: "[source of Python design blueprints]"
  implementation_scope: "[optional: application-wide|module-specific|class-hierarchy]"
  validation_level: "[optional: standard|comprehensive|continuous|strict]"
  commit_strategy: "[optional: atomic|feature-based|incremental]"
  quality_enforcement: "[optional: standard|strict|enterprise|maximum]"
```

### **SUCCESS CRITERIA:**

- [ ] MCP prompt executed with proper arguments and date stamps
- [ ] All implementation phases completed according to protocol with timestamp tracking
- [ ] 100% Python production code implemented
- [ ] All class hierarchies and interfaces implemented (timestamped)
- [ ] Complete SOLID principles implementation (timestamped)
- [ ] Design patterns fully operational (timestamped)
- [ ] Modern Python features implemented (timestamped)
- [ ] Error handling and type system active (timestamped)
- [ ] SOLID/DRY/KISS principles applied throughout (timestamped)
- [ ] Post-implementation quality check executed (timestamped)
- [ ] All deliverables produced as specified in YAML protocol with proper timestamps

### **MANDATORY DATE STAMP REQUIREMENTS:**

**CODE FILES ONLY - NO DOCUMENTATION TIMESTAMPS NEEDED**

Since this is a coding-only command with NO documentation deliverables:
- Source code files follow project naming conventions
- Configuration files use standard formats
- Test files integrate with existing test suites
- Build artifacts follow build system conventions

**NO .ipynb files will be created** - therefore no timestamp requirements for documentation deliverables.

**FORBIDDEN:**

- Creating any documentation files (as per NO DOCUMENTATION mandate)
- Generating .ipynb or .md files during implementation
- Producing reports or analysis documents of any kind

### **PYTHON CODE IMPLEMENTATION DELIVERABLES:**

**NO DOCUMENTATION DELIVERABLES - CODING ONLY COMMAND**

This command produces CODE ONLY:
- Source code files (.py, .ts, .js, etc.) in appropriate directories
- Configuration files as needed
- Test files for validation
- Build artifacts from compilation/bundling

**REMINDER**: This is a pure implementation command. NO Jupyter Notebooks, NO Markdown files, NO reports of any kind will be created. Documentation creation is STRICTLY FORBIDDEN per the protocol above.
- No code inventory documentation (analysis commands provide this)

**NEXT PHASE PREPARATION:**

```bash
# After implementation completion, execute quality validation with:
/python-code-quality-analysis [implementation-directory]

# Examples:
/python-code-quality-analysis ./src/application
/python-code-quality-analysis ./lib/core
/python-code-quality-analysis ./modules/components
```

## Command Integration

### Related Commands
- **Analysis Phase**: `/python-code-analysis` - Code analysis and understanding
- **Design Phase**: `/python-code-design` - Architecture and design patterns
- **Planning Phase**: `/python-code-framework-planning` - Implementation planning
- **Quality Assurance**: `/python-code-quality-analysis` - Quality assessment and validation
- **Code Improvement**: `/python-code-refactor` - Code refactoring and modernization
- **Quality Check**: `/python-code-lint-and-quality-check` - Automated quality fixes

### Workflow Navigation
```
Analysis  Design  Planning  Implementation  Quality Check  Refactor  Quality Analysis
                                                                       
Understand  Design   Plan     Build Code    Apply Fixes   Improve    Validate
```

### Next Phase Commands
After completing implementation, proceed with:
1. `/python-code-lint-and-quality-check` - Apply automatic quality fixes
2. `/python-code-quality-analysis` - Comprehensive quality assessment
3. `/python-code-refactor` - Code improvements and modernization (if needed)

---

**ENFORCEMENT:** This command performs PYTHON CODE IMPLEMENTATION ONLY through the MCP prompt protocol. The comprehensive implementation logic is defined in `python-code-framework-implement-prompt.yaml` and executed according to Model Context Protocol standards. No test code creation allowed. Use quality validation commands after implementation is complete and functional.